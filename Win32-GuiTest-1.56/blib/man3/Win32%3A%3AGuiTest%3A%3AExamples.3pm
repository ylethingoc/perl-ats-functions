.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Win32::GuiTest::Examples 3pm"
.TH Win32::GuiTest::Examples 3pm "2008-10-01" "perl v5.22.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Win32::GuiTest::Examples \- collection of the scripts from eg
.SH "Synopsis"
.IX Header "Synopsis"
This module was autogenerated from the files in the eg directory of
the distribution. For detailed (cough) documenataion see Win32::GuiTest.
To run the examples either copy-paste them from here or download and unpack
the distribution and take the files from the eg directory.
.SH "Examples"
.IX Header "Examples"
.SS "eg/ask.pl"
.IX Subsection "eg/ask.pl"
.Vb 1
\&    #!perl \-w
\&    
\&    #
\&    # Just ask a number of questions on the command line using
\&    # the functions provided by Win32::GuiTest::Cmd
\&    
\&    use strict;
\&    use Win32::GuiTest::Cmd \*(Aq:ALL\*(Aq;
\&    
\&    Pause("Press ENTER to start the setup...");
\&    
\&    print "GO!\en" if YesOrNo("Setup networking component?");
\&    
\&    my $address = AskForIt("What\*(Aqs your new ip address?", 
\&        "122.122.122.122");
\&    
\&    my $dir = AskForDir("Where should I put the new files?", 
\&        "c:\e\etemp");
\&    
\&    my $exe = AskForExe("Where is your net setup program?", 
\&        "/foo/bar.exe");
\&    
\&    print "\enAddress \*(Aq$address\*(Aq\en";
\&    print "Dir     \*(Aq$dir\*(Aq\en";
\&    print "Exe     \*(Aq$exe\*(Aq\en";
.Ve
.SS "eg/calc.pl"
.IX Subsection "eg/calc.pl"
.Vb 1
\&    #!perl \-w
\&    
\&    #
\&    # Written by Gabor Szabo <gabor@pti.co.il>
\&    # An example how to access the built in calculator (calc.exe) of Windows.
\&    # This code assumes your calulator defaults to the Standard view (and not the Scientific)
\&    
\&    
\&    
\&    use strict;
\&    
\&    use Win32::GuiTest qw(:ALL);
\&    
\&    if (not @ARGV or 
\&        ($ARGV[0] ne "keyboard" and  $ARGV[0] ne "mouse")) {
\&        die "Usage: $0 [keyboard|mouse]\en" 
\&    }
\&       
\&    system "start calc.exe";
\&    sleep(1);
\&    my @windows = FindWindowLike(undef, "Calculator");
\&    
\&    if (not @windows) {
\&       die "Could not find Calculator\en";
\&    }
\&    if (@windows > 1) {
\&       die "There might be more than one Calculators running\en";
\&    }
\&    
\&    if ($ARGV[0] eq "keyboard") {
\&       PushButton \*(Aq7\*(Aq;  
\&       sleep(1);
\&       PushButton \*(Aq\e*\*(Aq;
\&       sleep(1);
\&       PushButton \*(Aq5\*(Aq;
\&       sleep(1);
\&       PushButton \*(Aq=\*(Aq;
\&       sleep(2);
\&       
\&       # Catch the content of the first child, 
\&       # At this point we can only hope that this is the child that holds the result
\&       # as it does not have a title, maybe it has a type that we can check ?
\&       my @children = GetChildWindows($windows[0]);
\&       printf "Result: %s\en", WMGetText($children[0]);
\&       
\&       SendKeys("%{F4}");  # Alt\-F4 to exit
\&    }
\&    if ($ARGV[0] eq "mouse") {
\&       my ($left, $top, $right, $bottom) = GetWindowRect($windows[0]);
\&       # find the appropriate child window and click on  it
\&       my @children = GetChildWindows($windows[0]);
\&       foreach my $title (qw(7 * 5 =)) {
\&           my ($c) = grep {$title eq GetWindowText($_)} @children;
\&           my ($left, $top, $right, $bottom) = GetWindowRect($c);
\&           MouseMoveAbsPix(($right+$left)/2,($top+$bottom)/2);
\&           SendMouse("{LeftClick}");
\&           sleep(1);
\&       }
\&       printf "Result: %s\en", WMGetText($children[0]);
\&       
\&       MouseMoveAbsPix($right\-10,$top+10);  # this probably depends on the resolution
\&       sleep(2);
\&       SendMouse("{LeftClick}");
\&    }
.Ve
.SS "eg/excel.pl"
.IX Subsection "eg/excel.pl"
.Vb 2
\&    #!perl \-w
\&    #
\&    
\&    use strict;
\&    
\&    use Win32::GuiTest qw(FindWindowLike GetWindowText SetForegroundWindow);
\&    
\&    $Win32::GuiTest::debug = 0; # Set to "1" to enable verbose mode
\&    
\&    # Find top level (1) windows containg Excel in their title
\&    my @windows = FindWindowLike(undef, "Excel", "", undef, 1);
\&    for (@windows) {
\&        print "$_>\et\*(Aq", GetWindowText($_), "\*(Aq\en";
\&    }
\&    print "\-\-\-\-\-\-\-\-\-\-\-\-\en";
\&    
\&    # Find all windows matching Microsoft Excel in the title, and XLMAIN$
\&    # as the class. 
\&    @windows = FindWindowLike(undef, "^Microsoft Excel", "^XLMAIN\e$");
\&    for (@windows) {
\&        print "$_>\et\*(Aq", GetWindowText($_), "\*(Aq\en";
\&        SetForegroundWindow($_);
\&    }
\&    print "\-\-\-\-\-\-\-\-\-\-\-\-\en";
\&    
\&    die "You should start Excel before running this example.\en"
\&        unless @windows;
\&    
\&    # Find all children of a specified window.
\&    my @children = FindWindowLike($windows[0]);
\&    for (@children) {
\&        print "$_>\et\*(Aq", GetWindowText($_), "\*(Aq\en";
\&    }
.Ve
.SS "eg/excel2.pl"
.IX Subsection "eg/excel2.pl"
.Vb 1
\&    #!perl \-w
\&    
\&    #
\&    # Exercise Win32::GuiTest using MS\-Excel. Will only work with non\-localized
\&    # versions of Excel (hard\-coded hot\-keys).
\&    #
\&    
\&    use strict;
\&    use Win32::GuiTest qw(FindWindowLike GetWindowText 
\&    SetForegroundWindow SendKeys);
\&    
\&    $Win32::GuiTest::debug = 0; # Set to "1" to enable verbose mode
\&    
\&    my @windows = FindWindowLike(0, "^Microsoft Excel", "^XLMAIN\e$");
\&    
\&    die "You should start Excel before running this example.\en"
\&        unless @windows;
\&    
\&    print "$windows[0]>\et\*(Aq", GetWindowText($windows[0]), "\*(Aq\en\en";
\&    SetForegroundWindow($windows[0]);
\&    SendKeys("%fn~{PAUSE 1000}");
\&    SendKeys("Randal, look!{TAB}");
\&    SendKeys("Just{TAB}Another{TAB}Perl{TAB}Hacker{TAB}");
\&    SendKeys("{DOWN}{LEFT 5}This is another test!{TAB}{DOWN}{LEFT}");
\&    SendKeys("I hope we\*(Aqre on cell A3!{ENTER}");
\&    
\&    my @xl_children = FindWindowLike($windows[0]);
\&    for (@xl_children) {
\&        print "$_>\et\*(Aq", GetWindowText($_), "\*(Aq\en";
\&    }
\&    
\&    print "\en";
\&    
\&    SendKeys("{PAUSE 2000}%to{PAUSE 2000}");
\&    SendKeys("{ESC}Test finished.{ENTER}");
.Ve
.SS "eg/fonts.pl"
.IX Subsection "eg/fonts.pl"
.Vb 4
\&    #!perl \-w
\&    # Use Win32::GuiTest to get a list of supported fonts from a
\&    # dialog box.
\&    # By Ernesto Guisado (erngui@acm.org).
\&    
\&    use strict;
\&    
\&    use Win32::GuiTest qw(:ALL);
\&    
\&    #sub FontTxt { "Fuente"; } # i18n
\&    #sub OpenFont { "%ef"; }   # i18n
\&    
\&    # Let\*(Aqs see notepad
\&    system("start notepad.exe");
\&    sleep 1;
\&    
\&    # Open the Font dialog
\&    #SendKeys(OpenFont);
\&    MenuSelect("F&ormat|&Font");  # this is also language dependent !
\&    sleep(1);
\&    
\&    # Find the Font dialog using the title and window class
\&    # The Font dialog isn\*(Aqt a child of the notepad window
\&    #my ($fontdlg) = FindWindowLike(0, FontTxt); 
\&    my $fontdlg = GetForegroundWindow();
\&    die "We could not fing the Font dialog\en" if not defined $fontdlg;
\&    print GetWindowText($fontdlg), "\en\en";
\&    sleep(3);
\&    
\&    # Find the right combo using it\*(Aqs control id
\&    my ($combo) = FindWindowLike($fontdlg, "", "ComboBox", 0x470);
\&    die "Where is the combo with the font names?" unless $combo;
\&    
\&    # Print all the font names
\&    for (GetComboContents($combo)) {
\&        print "\*(Aq$_\*(Aq" . "\en";
\&    }
\&    
\&    # Close the dialog and notepad
\&    SendKeys("{ESC}%{F4}");
.Ve
.SS "eg/iswindowstyle.pl"
.IX Subsection "eg/iswindowstyle.pl"
.Vb 2
\&    #!/usr/bin/perl
\&    #
\&    
\&    use Win32::GuiTest qw(:FUNC :LVS);
\&    
\&    # Test IsWindowStyle()
\&    
\&    # Get handle to desktop listview.  Note: Tested on Win2k and NT4.
\&    my ($pm) = FindWindowLike(GetDesktopWindow(), "", "Progman");
\&    my ($sdv) = FindWindowLike($pm, "", "SHELLDLL_DefView");
\&    my ($dlv) = FindWindowLike($sdv, "", "SysListView32");
\&    # Check to see if desktop icons are marked for auto\-arrange.
\&    if (IsWindowStyle($dlv, LVS_AUTOARRANGE)) {
\&        print "Desktop icons are set to auto\-arranged.\en";
\&    } else {
\&        print "Desktop icons are NOT set to auto\-arranged.\en";
\&        ## Code to auto\-arrange desktop icons (MouseClick,SendKeys) ##
\&    }
.Ve
.SS "eg/keypress.pl"
.IX Subsection "eg/keypress.pl"
.Vb 4
\&    #!/usr/bin/perl
\&    # This example shows an easy way to check for certain keystrokes.
\&    # The IsKeyPressed function takes a string with the name of the key.
\&    # This names are the same ones as for SendKeys. 
\&    
\&    use Win32::GuiTest qw(SendKeys IsKeyPressed);
\&    
\&    # Wait until user presses several specified keys
\&    @keys = qw/ESC F5 F11 F12 A B 8 DOWN/;
\&    
\&    for (@keys) {
\&      until (IsKeyPressed($_)) {
\&        print "Please press $_...\en";
\&        SendKeys "{PAUSE 200}";
\&      }
\&    }
.Ve
.SS "eg/menuselect.pl"
.IX Subsection "eg/menuselect.pl"
.Vb 1
\&    #!perl \-w
\&    
\&    # Example how to get the names of the menus
\&    
\&    use strict;
\&    
\&    use Win32::GuiTest qw(:ALL);
\&    
\&    system "start notepad";
\&    sleep 1;
\&    
\&    my $menu = GetMenu(GetForegroundWindow());
\&    print "Menu: $menu\en";
\&    my $submenu = GetSubMenu($menu, 0);
\&    print "Submenu: $submenu\en";
\&    print "Count:", GetMenuItemCount($menu), "\en";
\&    
\&    use Data::Dumper;
\&    
\&    my %h = GetMenuItemInfo($menu, 1);   # Edit on the main menu
\&    print Dumper \e%h;
\&    %h = GetMenuItemInfo($submenu, 1);   # Open in the File menu
\&    print Dumper \e%h;
\&    %h = GetMenuItemInfo($submenu, 4);   # Separator in the File menu
\&    print Dumper \e%h;
\&    
\&    print "===================\en";
\&    menu_parse($menu);
\&    
\&    #MenuSelect("&Archivo|&Salir");
\&    
\&    # Close the menu and notepad
\&    SendKeys("{ESC}%{F4}");
\&    
\&    
\&    # this function receives a menu id and prints as much information about that menu and 
\&    # all its submenues as it can
\&    # One day we might include this in the distributionor in some helper module
\&    sub menu_parse {
\&        my ($menu, $depth) = @_;
\&        $depth ||= 0;
\&        
\&        foreach my $i (0..GetMenuItemCount($menu)\-1) {
\&                my %h = GetMenuItemInfo($menu, $i);
\&                print "   " x $depth;
\&                print "$i  ";
\&                print $h{text} if $h{type} and $h{type} eq "string"; 
\&                print "\-\-\-\-\-\-" if $h{type} and $h{type} eq "separator"; 
\&                print "UNKNOWN" if not $h{type};
\&                print "\en";
\&                
\&                my $submenu = GetSubMenu($menu, $i);
\&                if ($submenu) {
\&                        menu_parse($submenu, $depth+1);
\&                }
\&        }
\&    }
\&    
\&    
\&    SendKeys("%{F4}");
.Ve
.SS "eg/notepad.pl"
.IX Subsection "eg/notepad.pl"
.Vb 2
\&    #!/usr/bin/perl
\&    #
\&    
\&    use Win32::GuiTest;
\&    
\&    system("start notepad.exe");
\&    sleep 3;
\&    Win32::GuiTest::SendKeys("If you\*(Aqre reading this inside notepad,\en");
\&    Win32::GuiTest::SendKeys("we might consider this test succesful.\en");
\&    Win32::GuiTest::SendKeys("Now I\*(Aqll send notepad an ALT{+}F4 to close\en");
\&    Win32::GuiTest::SendKeys("it. Please wait.......");
\&    sleep 1;
\&    Win32::GuiTest::SendKeys(".");
\&    sleep 1;
\&    Win32::GuiTest::SendKeys(".");
\&    sleep 1;
\&    Win32::GuiTest::SendKeys(".");
\&    Win32::GuiTest::SendKeys("%{F4}{TAB}{ENTER}");
.Ve
.SS "eg/notepad_text.pl"
.IX Subsection "eg/notepad_text.pl"
.Vb 2
\&    #!perl \-w
\&    # If you have a notepad window open this prints the contents.
\&    
\&    use strict;
\&    
\&    use Win32::GuiTest qw(FindWindowLike WMGetText);
\&    
\&    my @windows = FindWindowLike(0, "", "Notepad");
\&    die "More than one notepad open\en" if @windows > 1;
\&    die "No notepad is running, please open one with some text in it.\en" if not @windows;
\&    
\&    my $notepad = $windows[0];
\&    my @edits = FindWindowLike($notepad, "", "Edit");
\&    die "More than one edit inside notepad: " .  @edits . "\en" if @edits > 1;
\&    die "No edit window found inside notepad\en" if not @edits;
\&    
\&    print "\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\en";
\&    print WMGetText($edits[0]);
\&    print "\en";
\&    print "\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\en";
.Ve
.SS "eg/paint.pl"
.IX Subsection "eg/paint.pl"
.Vb 2
\&    #!perl \-w
\&    # Draw triangles in MS Paint.
\&    
\&    
\&    use strict;
\&    
\&    use Win32::GuiTest qw(:ALL); 
\&    
\&    system("start /max mspaint");
\&    sleep 2;
\&    my @windows = FindWindowLike(0, "Paint", "");
\&    die "Could not find Paint\en" if not @windows;
\&    
\&    
\&    SetForegroundWindow($windows[0]);
\&    sleep 1;
\&    
\&    # totaly guess work about the location of the area where one can draw.
\&    # A better guess would be welcome
\&    MouseMoveAbsPix((GetWindowRect($windows[0]))[0,1]);
\&    SendMouse ( "{REL50,50}" );  
\&    
\&    # Using high\-level functions
\&    SendMouse ( "{LEFTDOWN}" );
\&    for (1..100) { SendMouse ( "{REL1,1}"  ); }
\&    for (1..100) { SendMouse ( "{REL1,\-1}" ); }
\&    for (1..200) { SendMouse ( "{REL\-1,0}" ); }
\&    SendMouse ( "{LEFTUP}" );
\&    
\&    
\&    
\&    # Using low level functions
\&    SendMouseMoveRel(5,20);
\&    SendLButtonDown();
\&    for (1..100) { SendMouseMoveRel(1,1);  }
\&    for (1..100) { SendMouseMoveRel(1,\-1); }
\&    for (1..200) { SendMouseMoveRel(\-1,0); }
\&    SendLButtonUp();
.Ve
.SS "eg/paint_abs.pl"
.IX Subsection "eg/paint_abs.pl"
.Vb 7
\&    #!perl \-w
\&    #
\&    # Draw an X and a box around it
\&    #
\&    use strict;
\&    use Win32::GuiTest qw(FindWindowLike SetForegroundWindow 
\&        SendMouse MouseMoveAbsPix SendLButtonDown SendLButtonUp);
\&    
\&    system("start /max mspaint");
\&    sleep 2;
\&    my @windows = FindWindowLike(0, "Paint", "");
\&    die "Could not find Paint\en" if not @windows;
\&    
\&    SetForegroundWindow($windows[0]);
\&    sleep 1;
\&    
\&    #Using low level functions
\&    MouseMoveAbsPix(100,100);
\&    SendLButtonDown();
\&    MouseMoveAbsPix(300,300);
\&    SendLButtonUp();
\&    
\&    
\&    sleep 1;
\&    
\&    MouseMoveAbsPix(100,300);
\&    SendLButtonDown();
\&    MouseMoveAbsPix(300,100);
\&    SendLButtonUp();
\&    
\&    sleep 1;
\&        
\&    MouseMoveAbsPix(100,100);
\&    SendLButtonDown();
\&    MouseMoveAbsPix(300,100);
\&    MouseMoveAbsPix(300,300);
\&    MouseMoveAbsPix(100,300);
\&    MouseMoveAbsPix(100,100);
\&    SendLButtonUp();
.Ve
.SS "eg/pushbutton.pl"
.IX Subsection "eg/pushbutton.pl"
.Vb 2
\&    #!/usr/bin/perl
\&    #
\&    
\&    use strict;
\&    use Win32::GuiTest qw(PushButton FindWindowLike SetForegroundWindow
\&        SendKeys WaitWindow IsWindow);
\&    
\&                                  
\&    # Test PushButton()
\&    
\&    # Remove old saved document
\&    unlink("C:\e\etemp\e\ePushButton.txt");
\&    
\&    system("start notepad.exe");
\&    my @windows = WaitWindow("Untitled \- Notepad");
\&    #my @windows = WaitWindow(" \- Bloc de notas");
\&    die unless scalar @windows == 1 && IsWindow($windows[0]);
\&    SetForegroundWindow($windows[0]);
\&    SendKeys("Sample Text\en");
\&    SendKeys("%{F4}");
\&    # Push Yes button to save document
\&    PushButton("Yes");
\&    #PushButton("Sí");
\&    # Type Filename
\&    SendKeys("C:\e\etemp\e\ePushButton.txt");
\&    # Push &Save to save and exit
\&    PushButton("&Save");
\&    #PushButton("&Guardar");
.Ve
.SS "eg/rawkey.pl"
.IX Subsection "eg/rawkey.pl"
.Vb 2
\&    #!/usr/bin/perl
\&    #
\&    
\&    use Win32::GuiTest qw(:FUNC :VK);
\&    
\&    while (1) {
\&        SendRawKey(VK_DOWN, KEYEVENTF_EXTENDEDKEY); 
\&        SendKeys "{PAUSE 200}";
\&    }
.Ve
.SS "eg/selecttabitem.pl"
.IX Subsection "eg/selecttabitem.pl"
.Vb 2
\&    #!/usr/bin/perl
\&    #
\&    
\&    use Win32::GuiTest qw(GetWindowID GetChildWindows GetWindowText
\&        GetForegroundWindow PostMessage PushButton SendKeys SelectTabItem);
\&    
\&    use Win32::GuiTest::Cmd qw(System);
\&    
\&    # Test 
\&    
\&    # Open System Properties
\&    # Tested on Win2k an NT4
\&    System();
\&    #system("start RunDLL32.exe shell32,Control_RunDLL sysdm.cpl,\e@0,2");
\&    sleep(2);
\&    # Select various items on tab control
\&    # Using Window ID
\&    SelectTabItem(12320, 0);
\&    sleep(1);
\&    SelectTabItem(12320, 2);
\&    sleep(1);
\&    SelectTabItem(12320, 1);
\&    sleep(1);
\&    #PushButton("^Cancel");
\&    SendKeys("{ESC}");
.Ve
.SS "eg/showcpl.pl"
.IX Subsection "eg/showcpl.pl"
.Vb 3
\&    #!/usr/bin/perl
\&    # Shows how to open control panel apps programmatically
\&    #
\&    
\&    use Win32::GuiTest::Cmd qw(
\&        Accessibility AppWizard Console DateTime
\&        Display Exchange Internet Joystick Modem
\&        Mouse Multimedia Network Odbc Pcmcia Ports Ras
\&        Regional Server System Telephony Ups Users);
\&    
\&    use Win32::GuiTest qw(SendKeys);
\&    
\&    Modem(); sleep 1;
\&    SendKeys("%{F4}");
\&    Network();sleep 1;
\&    SendKeys("%{F4}"); 
\&    Console();sleep 1;
\&    SendKeys("%{F4}"); 
\&    Accessibility();sleep 1;
\&    SendKeys("%{F4}"); 
\&    AppWizard();   sleep 1;
\&    SendKeys("%{F4}"); 
\&    Pcmcia();     sleep 1;
\&    SendKeys("%{F4}"); 
\&    Regional(); sleep 1;
\&    SendKeys("%{F4}"); 
\&    Joystick(); sleep 1;
\&    SendKeys("%{F4}"); 
\&    Mouse(); sleep 1;
\&    SendKeys("%{F4}"); 
\&    Multimedia(); sleep 1;
\&    SendKeys("%{F4}"); 
\&    Odbc(); sleep 1;
\&    SendKeys("%{F4}"); 
\&    Ports(); sleep 1;
\&    SendKeys("%{F4}"); 
\&    Server(); sleep 1;
\&    SendKeys("%{F4}"); 
\&    System(); sleep 1;
\&    SendKeys("%{F4}"); 
\&    Telephony();sleep 1;
\&    SendKeys("%{F4}"); 
\&    DateTime();sleep 1;
\&    SendKeys("%{F4}"); 
\&    Ups();sleep 1;
\&    SendKeys("%{F4}"); 
\&    Internet(); sleep 1;
\&    SendKeys("%{F4}"); 
\&    Display(); sleep 1;
\&    SendKeys("%{F4}"); 
\&    Ras(); sleep 1;
\&    SendKeys("%{F4}"); 
\&    Users(); sleep 1;
\&    SendKeys("%{F4}");
.Ve
.SS "eg/showmouse.pl"
.IX Subsection "eg/showmouse.pl"
.Vb 2
\&    #!/usr/bin/perl
\&    # This script has been written by Jarek Jurasz jurasz@imb.uni\-karlsruhe.de
\&    
\&    use Win32::GuiTest qw(GetCursorPos);
\&    
\&    while (1)
\&    {
\&      ($x, $y) = GetCursorPos();
\&      print "\erx:$x  y:$y   ";
\&      sleep 1;
\&    }
.Ve
.SS "eg/showwin.pl"
.IX Subsection "eg/showwin.pl"
.Vb 4
\&    #!/usr/bin/perl
\&    # This script has been written by Jarek Jurasz jurasz@imb.uni\-karlsruhe.de
\&    # selectively show/hide a group of windows
\&    # side effect: showing the window activates it
\&    
\&    use Win32::GuiTest qw(:ALL :SW);
\&    
\&    
\&    $name = shift;
\&    $show = shift;
\&    $class = undef;
\&    
\&    die <<EOT unless $name;
\&    Usage: $0 "^Title" [+1|\-1]
\&    +1 show windows
\&    \-1 hide windows
\&     0 or empty show status
\&    Be careful when using bare title words: when running the script, the title of 
\&    the console will change and include the title words, too...
\&    EOT
\&    
\&    
\&    # $name = "^Microsoft Excel" unless $name;
\&    my @win = FindWindowLike(0, $name, $class);
\&    
\&    showall(@win);
\&    
\&    sub showall
\&    {
\&      my @win = @_;
\&      for $win (@win)
\&      {
\&        # should normally be only one
\&        show($win);
\&        # children
\&        # showall(FindWindowLike($win, undef, undef));
\&      }
\&    }
\&    
\&    sub show
\&    {
\&      my $win = shift;
\&    
\&      # dumpwin($win);
\&      if ($show > 0)
\&      {
\&        ShowWindow($win, SW_SHOW) unless (IsWindowVisible($win));
\&        # EnableWindow($win, 1);
\&      }
\&      elsif ($show < 0)
\&      {
\&        ShowWindow($win, SW_HIDE) if (IsWindowVisible($win));
\&      }
\&      
\&      dumpwin($win);
\&    }
\&    
\&    sub dumpwin
\&    {
\&      my $win = shift;
\&      print "Null handle\en", return unless ($win);
\&      print "$win>\ett:", GetWindowText($win), " c:", GetClassName($win);
\&      print " vis:", IsWindowVisible($win);
\&      print " en:", IsWindowEnabled($win);
\&      print "\en";
\&    }
.Ve
.SS "eg/spy\-\-.pl"
.IX Subsection "eg/spy--.pl"
.Vb 4
\&    #!/usr/bin/perl
\&    # MS has a very nice tool (Spy++).
\&    # This is Spy\-\-
\&    #
\&    
\&    use Win32::GuiTest qw(FindWindowLike GetWindowText GetClassName
\&        GetChildDepth GetDesktopWindow);
\&    
\&    for (FindWindowLike()) {
\&        $s = sprintf("0x%08X", $_ );
\&        $s .= ", \*(Aq" .  GetWindowText($_) . "\*(Aq, " . GetClassName($_);
\&        print "+" x GetChildDepth(GetDesktopWindow(), $_), $s, "\en";
\&    }
.Ve
.SS "eg/spy.pl"
.IX Subsection "eg/spy.pl"
.Vb 2
\&    #!perl \-w
\&    use strict;
\&    
\&    # Based on the spy\-\-.pl within the distribution
\&    # Parse a subtree of the whole windoing systme and print as much information as possible
\&    # about each window and each object.
\&    # This software is in a very early stage. Its options and output format will change a lot.
\&    # Your input is welcome !
\&    
\&    # Written by Gabor Szabo <gabor@pti.co.il>
\&    
\&    my $VERSION = "0.02";
\&    
\&    use Getopt::Long;
\&    use Win32::GuiTest qw(:ALL);
\&    my %opts;
\&    GetOptions(\e%opts, "help", "title=s", "all", "id=i", "class=s"); 
\&    usage() if $opts{help} or not %opts;
\&    
\&    
\&    my %seen;
\&    my $desktop = GetDesktopWindow();
\&    my $root    = 0;
\&    my $start;
\&    
\&    $start = 0 if $opts{all};
\&    $start = $opts{id} if $opts{id};
\&    if ($opts{title} or $opts{class}) {
\&        my @windows = FindWindowLike(0, $opts{title}, $opts{class});
\&        #my @windows = FindWindowLike(0, $opts{title}) if $opts{title};
\&        #@windows = FindWindowLike(0, \*(Aq\*(Aq, $opts{class}) if $opts{class};
\&        if (@windows > 1) {
\&                print "There are more than one window that fit:\en";
\&                foreach my $w (@windows) {
\&                        printf "%s | %s | %s\en", $w,  GetClassName($w), GetWindowText($w);
\&                }
\&                exit;
\&        }
\&        die "Did not find such a window." if not @windows;
\&        $start = $windows[0];
\&    }
\&    
\&    
\&    
\&    
\&    
\&    
\&    usage() if not defined $start;
\&    
\&    
\&    my $format = "%\-10s %\-10s, \*(Aq%\-25s\*(Aq, %\-10s, Rect:%\-3s,%\-3s,%\-3s,%\-3s   \*(Aq%s\*(Aq\en";
\&    printf $format,
\&                "Depth",
\&                "WindowID",
\&                "ClassName",
\&                "ParentID",
\&                "WindowRect","","","",
\&                "WindowText";
\&    
\&    
\&    parse_tree($start);
\&    
\&    
\&    
\&    sub GetImmediateChildWindows {
\&        my $WinID = shift;
\&        grep {GetParent($_) eq $WinID} GetChildWindows $WinID;
\&    }
\&    
\&    sub parse_tree {
\&        my $w = shift;
\&        if ($seen{$w}++) {
\&                print "loop $w\en";
\&                return;
\&        }
\&    
\&        prt($w);
\&        #foreach my $child (GetChildWindows($w)) {
\&        #       parse_tree($child);
\&        #}
\&        foreach my $child (GetImmediateChildWindows($w)) {
\&                print "\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\en" if $w == 0;
\&                parse_tree($child);
\&        }
\&    }
\&    
\&    # GetChildDepth is broken so here is another version, this might work better.
\&     
\&    # returns the real distance between two windows
\&    # returns 0 if the same windows were provides
\&    # returns \-1 if one of the values is not a valid window
\&    # returns \-2 if the given "ancestor" is not really an ancestor of the given "descendant"
\&    sub MyGetChildDepth {
\&        my ($ancestor, $descendant) = @_;
\&        return \-1 if $ancestor and (not IsWindow($ancestor) or not IsWindow($descendant));
\&        return 0 if $ancestor == $descendant;
\&        my $depth = 0;
\&        while ($descendant = GetParent($descendant)) {
\&                $depth++;
\&                last if $ancestor == $descendant;
\&        }
\&        return $depth + 1 if $ancestor == 0;
\&    }
\&    
\&    
\&    sub prt {
\&        my $w = shift;
\&        my $depth = MyGetChildDepth($root, $w);
\&        printf $format,
\&                (0 <= $depth ? "+" x $depth : $depth),
\&                $w, 
\&                ($w ? GetClassName($w) : ""),
\&                ($w ? GetParent($w) : "n/a"),
\&                ($w ? GetWindowRect($w) : ("n/a", "", "", "")),
\&                ($w ? GetWindowText($w) : ""); 
\&    }
\&    
\&    
\&    
\&    sub usage {
\&        print "Version: v$VERSION\en";
\&        print "Usage:\en";
\&        print "        $0 \-\-help\en";
\&        print "        $0 \-\-all\en";
\&        print "        $0 \-\-title TITLE\en";
\&        print "\en";
\&        print "As the output is quite verbose, probably you\*(Aqll want to redirect \en";
\&        print "the output to a file:   $0 options > out.txt\en";
\&        print "\en";
\&        exit;
\&    }
.Ve
.SS "eg/start.pl"
.IX Subsection "eg/start.pl"
.Vb 1
\&    #!/usr/bin/perl
\&    
\&    # Disclaimer: I tried this on my WindowsXP,
\&    # Other Windows, or other configurations might place the "Run" option
\&    # of the "Start" menu in different place so before running this script
\&    # make sure that your version of Windows will bring you to the "Run" option
\&    # if you press the left windows key and then the Up key 3 times.
\&    
\&    # Written by Gabor Szabo <gabor@pti.co.il>
\&    
\&    use Win32::GuiTest;
\&    
\&    # open the Start menu by pressing the Left Windows Key 
\&    # and then close it by hitting ESC.
\&    Win32::GuiTest::SendKeys("{LWI}");
\&    sleep 2;
\&    Win32::GuiTest::SendKeys("{ESC}");
\&    
\&    # Check out the version of your perl by opening a cmd.exe and typing perl \-v
\&    # the sleep 1; lines were added only so the viewer can observe the process
\&    # you could actually send all the keys in one SendKeys call.
\&    
\&    Win32::GuiTest::SendKeys("{LWI}");
\&    sleep 1;
\&    Win32::GuiTest::SendKeys("{UP}");
\&    sleep 1;
\&    Win32::GuiTest::SendKeys("{UP}");
\&    sleep 1;
\&    Win32::GuiTest::SendKeys("{UP}");
\&    sleep 1;
\&    Win32::GuiTest::SendKeys("{ENTER}");
\&    sleep 1;
\&    Win32::GuiTest::SendKeys("cmd{ENTER}");
\&    sleep 1;
\&    Win32::GuiTest::SendKeys("perl \-v");
\&    sleep 1;
\&    Win32::GuiTest::SendKeys("{ENTER}");
\&    sleep 1;
\&    Win32::GuiTest::SendKeys("exit");
\&    sleep 1;
\&    Win32::GuiTest::SendKeys("{ENTER}");
.Ve
.SS "eg/tab.pl"
.IX Subsection "eg/tab.pl"
.Vb 2
\&    #!/usr/bin/perl
\&    #
\&    
\&    use Win32::GuiTest qw(:FUNC :VK);
\&    
\&    SendRawKey(VK_MENU, 0);
\&    SendKeys("{TAB}{PAU 1000}{TAB}{PAU 1000}{TAB}");
\&    SendRawKey(VK_MENU, KEYEVENTF_KEYUP);
.Ve
.SS "eg/waitwindow.pl"
.IX Subsection "eg/waitwindow.pl"
.Vb 3
\&    #!/usr/bin/perl
\&    # Slightly modified from version submitted by anonymous contributor.
\&    #
\&    
\&    use strict;
\&    use Win32::GuiTest qw(IsWindow FindWindowLike SendKeys
\&        PushButton WaitWindow); 
\&    
\&    
\&    # Test WaitWindow()
\&    
\&    # en i18n constants 
\&    sub SOL  { "^Solitaire" }
\&    sub GAME { "%G" }
\&    sub OPT  { "O" }
\&    sub OPTIONS { "^Options" }
\&    sub CANCEL  { "Cancel" }
\&    
\&    # es i18n constants 
\&    #sub SOL  { "^Solitario" }
\&    #sub GAME { "%J" }
\&    #sub OPT  { "O" }
\&    #sub OPTIONS { "^Opciones" }
\&    #sub CANCEL  { "Cancelar" }
\&    
\&    # Open program
\&    system("start sol.exe");
\&    # Wait for program window to appear.
\&    die "Couldn\*(Aqt open solitaire program!\en"
\&        unless WaitWindow(SOL);
\&    # Select game menu
\&    SendKeys(GAME);
\&    # Open options menu
\&    SendKeys(OPT); 
\&    # Wait for options menu to appear for up to 5 seconds.
\&    WaitWindow(OPTIONS, 5);
\&    # Close options menu
\&    PushButton(CANCEL);
\&    # Close program
\&    SendKeys("%{F4}");
.Ve
.SS "eg/which.pl"
.IX Subsection "eg/which.pl"
.Vb 10
\&    #!/usr/bin/perl
\&    # Similar to UNIX which command.
\&    #
\&    # On my NT box:
\&    # 
\&    #  D:\esrc\eperl\ewin32\-guitest>eg\ewhich.pl perl
\&    #  D:\eperl\ebin\eperl.EXE
\&    #  D:\esrc\eperl\ewin32\-guitest>eg\ewhich.pl regedit
\&    #  C:\eWINNT\eregedit.EXE
\&    #  D:\esrc\eperl\ewin32\-guitest>eg\ewhich.pl notepad
\&    #  C:\eWINNT\esystem32\enotepad.EXE
\&    #  D:\esrc\eperl\ewin32\-guitest>
\&    #
\&    
\&    use strict;
\&    use Win32::GuiTest::Cmd qw(WhichExe);
\&    print WhichExe(shift);
.Ve
.SS "eg/winbmp.pl"
.IX Subsection "eg/winbmp.pl"
.Vb 4
\&    #!/usr/bin/perl
\&    # This script has been written by Jarek Jurasz jurasz@imb.uni\-karlsruhe.de
\&    # Save a given window as BMP file
\&    # Copy the contents to the clipboard
\&    
\&    
\&    use Win32::GuiTest qw(:ALL);
\&    
\&    ($w) = FindWindowLike(0, "^Calc");
\&    $w = GetDesktopWindow unless $w;
\&    
\&    $ds = new Win32::GuiTest::DibSect;
\&    $ds\->CopyWindow($w);
\&    #$ds\->CopyClient(GetDesktopWindow(), \e@{[GetWindowRect($w)]});
\&    # $ds\->Invert();
\&    #$ds\->CopyClient(GetDesktopWindow(), \e@{[GetWindowRect($w)]});
\&    # $ds\->Invert();
\&    #$ds\->ToGrayScale();
\&    $ds\->SaveAs("bla.bmp");
\&    $ds\->ToClipboard();
.Ve
.SS "eg/wptr.pl"
.IX Subsection "eg/wptr.pl"
.Vb 2
\&    #!/usr/bin/perl
\&    #
\&    
\&    # Module Pragmas
\&    use strict;
\&    use warnings;
\&    
\&    # Module Imports
\&    use Win32::GuiTest qw(GetCursorPos GetClassName GetWindowText
\&        GetWindowRect WindowFromPoint GetWindowID IsKeyPressed WMGetText);
\&    use Win32::Clipboard;
\&    
\&    # Module Level Variables
\&    my $Clip = Win32::Clipboard();
\&    my $cur_info = "";
\&    my $oldhwnd = 0;
\&    my $oldcx = 0;
\&    my $oldcy = 0;
\&    
\&    # Core Loop
\&    while (1) {
\&        my ($cx, $cy) = GetCursorPos();
\&        # Is different cursor position?
\&        if ( ($cx != $oldcx) || ($cy != $oldcy) ) {
\&                $oldcx = $cx;
\&                $oldcy = $cy;
\&                # Get handle of window
\&                my $hwnd = WindowFromPoint($cx, $cy);
\&                if ($hwnd == $oldhwnd) {
\&                        # Same window as before, don\*(Aqt query information again.
\&                        next;
\&                }
\&                # Different window, so cache the handle value.
\&                $oldhwnd = $hwnd;
\&                # Get information for the new window in which the cursor is over.
\&                $cur_info = GetWindowInfo($hwnd);
\&                ClearScreen();
\&                # Output window information to console.
\&                DispWindowInfo($cur_info);
\&                # Display menu.
\&                DispMenu();
\&        }
\&        # INSERT to copy window data to clipboard.
\&        if (IsKeyPressed("INS")) {
\&                $Clip\->Empty();
\&                $Clip\->Set($cur_info);
\&                select(undef, undef, undef, 0.50);
\&                print "Copied data to clipboard.\en";
\&        }
\&        # ESCAPE to exit this program.
\&        if (IsKeyPressed("ESC")) {
\&                print "Goodbye!\en";
\&                last;
\&        }
\&    }
\&    
\&    
\&    sub ClearScreen {
\&        system("command /c cls");
\&        return;
\&    }
\&    
\&    sub GetWindowInfo {
\&        my $hwnd = shift;
\&        my $info =              "# Window Text: \*(Aq" . GetWindowText($hwnd) . "\*(Aq\er\en";
\&        $info = $info . "# Window Class: \*(Aq" . GetClassName($hwnd) . "\*(Aq\er\en";
\&        $info = $info . "# Window ID: " . GetWindowID($hwnd) . "\er\en";
\&        my ($left, $top, $right, $bottom) = GetWindowRect($hwnd);
\&        $info = $info . "# Window Rect: ($left, $top) \- ($right, $bottom)\er\en";
\&    print "Text: " . WMGetText($hwnd) . "\er\en";
\&        return($info);
\&    }
\&    
\&    sub DispWindowInfo {
\&        print shift;
\&        return;
\&    }
\&    
\&    sub DispMenu {
\&        print "\en\enPress <INSERT> to copy window text to clipboard.\en";
\&        print "Press <ESCAPE> to exit program.\en";
\&        return;
\&    }
.Ve
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 504:" 4
.IX Item "Around line 504:"
Non-ASCII character seen before =encoding in '#PushButton(\*(L"Sí\*(R");'. Assuming \s-1CP1252\s0
