.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Win32::GuiTest 3pm"
.TH Win32::GuiTest 3pm "2008-10-01" "perl v5.22.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Win32::GuiTest \- Perl GUI Test Utilities.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use Win32::GuiTest qw(FindWindowLike GetWindowText 
\&    SetForegroundWindow SendKeys);
\&
\&  $Win32::GuiTest::debug = 0; # Set to "1" to enable verbose mode
\&
\&  my @windows = FindWindowLike(0, "^Microsoft Excel", "^XLMAIN\e$");
\&  for (@windows) {
\&      print "$_>\et\*(Aq", GetWindowText($_), "\*(Aq\en";
\&      SetForegroundWindow($_);
\&      SendKeys("%fn~a{TAB}b{TAB}{BS}{DOWN}");
\&  }
.Ve
.SH "INSTALLATION"
.IX Header "INSTALLATION"
.Vb 3
\&    // This batch file comes with MS Visual Studio.  Running
\&    // it first might help with various compilation problems.
\&    vcvars32.bat 
\&
\&    perl makefile.pl
\&    nmake
\&    nmake test
\&    nmake install
\&
\&    See more details in the DEVELOPMENT section elswhere in this document.
.Ve
.PP
You can get the most recent release from 
<http://www.sourceforge.net/projects/winguitest>. The package will
contain Win32\-GuiTest.ppd file and Win32\-GuiTest.tar.gz file, 
which is all that you need to use
ppm. If you put those 2 files in C:\eTEMP directory, the installation
should look as follows.  Enter \s-1PPM \s0(Perl Package Manager) from the 
command-line and type commands as below
.PP
.Vb 7
\&    C:\eTEMP>ppm
\&    PPM interactive shell (2.0) \- type \*(Aqhelp\*(Aq for available commands.
\&    PPM> install C:\etemp\ewin32\-guitest.ppd
\&    Install package \*(AqC:\etemp\ewin32\-guitest.ppd?\*(Aq (y/N): Y
\&    Retrieving package \*(AqC:\etemp\ewin32\-guitest.ppd\*(Aq...
\&    Writing C:\ePerl\esite\elib\eauto\eWin32\eGuiTest\e.packlist
\&    PPM>
.Ve
.PP
I extracted them to 'c:\etemp', please use the directory where you extracted 
the files instead.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Most \s-1GUI\s0 test scripts I have seen/written for Win32 use some variant of Visual
Basic (e.g. MS-VB or MS-Visual Test). The main reason is the availability of
the SendKeys function.
.PP
A nice way to drive Win32 programs from a test script is to use \s-1OLE\s0 Automation
(ActiveX Scripting), but not all Win32 programs support this interface. That is
where SendKeys comes handy.
.PP
Some time ago Al Williams published a Delphi version in Dr. Dobb's
(http://www.ddj.com/ddj/1997/careers1/wil2.htm). I ported it to C and
packaged it using h2xs...
.PP
The tentative name for this module is Win32::GuiTest (mostly because I plan to
include more \s-1GUI\s0 testing functions).
.PP
I've created a Yahoo Group for the module that you can join at
   http://groups.yahoo.com/group/perlguitest/join
.PP
Also, an initial version of a script recording application has been written to use with this 
module.  A copy of it may be found with this distribution (Recorder\eWin32GuiTest.exe)
or can be obtained at http://sourceforge.net/projects/winguitest
.PP
If the documentation of these functions is not satisfactory, you can 
try running a search on http://msdn.microsoft.com/ using the name of the function. 
Some of these functions are described there.
.PP
This distribution of the module \- the one you are looking at now \- has
its own \s-1CVS\s0 repository at http://sourceforge.net/projects/winguitest
Patches to both the code and the documentation are welcome.
.SS "Functions"
.IX Subsection "Functions"
.ie n .IP "$debug" 4
.el .IP "\f(CW$debug\fR" 4
.IX Item "$debug"
When set enables the verbose mode.
.IP "SendKeys($keys[,$delay])" 4
.IX Item "SendKeys($keys[,$delay])"
Sends keystrokes to the active window as if typed at the keyboard using the
optional delay between key-up and key-down messages (default is 25 ms and
should be \s-1OK\s0 for most uses).
.Sp
The keystrokes to send are specified in \s-1KEYS.\s0 There are several
characters that have special meaning. This allows sending control codes 
and modifiers:
.Sp
.Vb 4
\&        ~ means ENTER
\&        + means SHIFT 
\&        ^ means CTRL 
\&        % means ALT
.Ve
.Sp
The parens allow character grouping. You may group several characters, so
that a specific keyboard modifier applies to all of them. Groups can
be enclosed in groups.
.Sp
E.g. SendKeys(\*(L"\s-1ABC\*(R"\s0) is equivalent to SendKeys(\*(L"+(abc)\*(R")
.Sp
The curly braces are used to quote special characters (SendKeys(\*(L"{+}{{}\*(R")
sends a '+' and a '{'). You can also use them to specify certain named actions:
.Sp
.Vb 1
\&        Name          Action
\&
\&        {BACKSPACE}   Backspace
\&        {BS}          Backspace
\&        {BKSP}        Backspace
\&        {BREAK}       Break
\&        {CAPS}        Caps Lock
\&        {DELETE}      Delete
\&        {DOWN}        Down arrow
\&        {END}         End
\&        {ENTER}       Enter (same as ~)
\&        {ESCAPE}      Escape
\&        {HELP}        Help key
\&        {HOME}        Home
\&        {INSERT}      Insert
\&        {LEFT}        Left arrow
\&        {NUMLOCK}     Num lock
\&        {PGDN}        Page down
\&        {PGUP}        Page up
\&        {PRTSCR}      Print screen
\&        {RIGHT}       Right arrow
\&        {SCROLL}      Scroll lock
\&        {TAB}         Tab
\&        {UP}          Up arrow
\&        {PAUSE}       Pause
\&        {F1}          Function Key 1
\&        ...           ...
\&        {F24}         Function Key 24
\&        {SPC}         Spacebar
\&        {SPACE}       Spacebar
\&        {SPACEBAR}    Spacebar
\&        {LWI}         Left Windows Key
\&        {RWI}         Right Windows Key 
\&        {APP}         Open Context Menu Key
.Ve
.Sp
or supply a number that will be treated as a \s-1VK\s0 code. Note that a single-digit
number will be treated as a character, so prepend these with '0'.
.Sp
All these named actions take an optional integer argument, like in {\s-1RIGHT 5\s0}. 
For all of them, except \s-1PAUSE,\s0 the argument means a repeat count. For \s-1PAUSE\s0
it means the number of milliseconds SendKeys should pause before proceding.
.Sp
In this implementation, SendKeys always returns after sending the keystrokes.
There is no way to tell if an application has processed those keys when the
function returns.
.Sp
Unicode characters in \f(CW$keys\fR are translated into set of \s-1ALT+NUMPAD\s0 keystrokes.
Note that not all applications can understand unicode input.
.IP "SendMouse($command)" 4
.IX Item "SendMouse($command)"
This function emulates mouse input.  The \s-1COMMAND\s0 parameter is a string
containing one or more of the following substrings:
.Sp
.Vb 11
\&        {LEFTDOWN}    left button down
\&        {LEFTUP}      left button up
\&        {MIDDLEDOWN}  middle button down
\&        {MIDDLEUP}    middle button up
\&        {RIGHTDOWN}   right button down
\&        {RIGHTUP}     right button up
\&        {LEFTCLICK}   left button single click
\&        {MIDDLECLICK} middle button single click
\&        {RIGHTCLICK}  right button single click
\&        {ABSx,y}      move to absolute coordinate ( x, y )
\&        {RELx,y}      move to relative coordinate ( x, y )
.Ve
.Sp
Note: Absolute mouse coordinates range from 0 to 65535.
      Relative coordinates can be positive or negative.
      If you need pixel coordinates you can use MouseMoveAbsPix.
.Sp
Also equivalent low-level functions are available:
.Sp
.Vb 8
\&    SendLButtonUp()
\&    SendLButtonDown()
\&    SendMButtonUp()
\&    SendMButtonDown()
\&    SendRButtonUp()
\&    SendRButtonDown()
\&    SendMouseMoveRel(x,y)
\&    SendMouseMoveAbs(x,y)
.Ve
.IP "MouseMoveAbsPix($x,$y)" 4
.IX Item "MouseMoveAbsPix($x,$y)"
Move the mouse cursor to the screen pixel indicated as parameter.
.Sp
.Vb 2
\&  # Moves to x=200, y=100 in pixel coordinates.
\&  MouseMoveAbsPix(200, 100);
.Ve
.IP "MouseMoveWheel($change)" 4
.IX Item "MouseMoveWheel($change)"
.Vb 1
\&  Positive or negative value to direct mouse wheel movement.
.Ve
.IP "FindWindowLike($window,$titleregex,$classregex,$childid,$maxlevel)" 4
.IX Item "FindWindowLike($window,$titleregex,$classregex,$childid,$maxlevel)"
Finds the window handles of the windows matching the specified parameters and
returns them as a list.
.Sp
You may specify the handle of the window to search under. The routine 
searches through all of this windows children and their children recursively.
If 'undef' then the routine searches through all windows. There is also a 
regexp used to match against the text in the window caption and another regexp
used to match against the text in the window class. If you pass a child \s-1ID \s0
number, the functions will only match windows with this id. In each case 
undef matches everything.
.IP "GetWindowID($window)" 4
.IX Item "GetWindowID($window)"
.Vb 1
\&    Returns the control Id of the specified window.
.Ve
.IP "PushButton($button[,$delay])" 4
.IX Item "PushButton($button[,$delay])"
Equivalent to
.Sp
.Vb 1
\&    PushChildButton(GetForegroundWindow, BUTTON, DELAY)
.Ve
.IP "PushChildButton($parent,$button[,$delay])" 4
.IX Item "PushChildButton($parent,$button[,$delay])"
Allows generating a mouse click on a particular button.
.Sp
parent \- the parent window of the button
.Sp
button \- either the text in a button (e.g. \*(L"Yes\*(R") or the control \s-1ID\s0
of a button.
.Sp
delay \- the time (0.25 means 250 ms) to wait between the mouse down
and the mouse up event. This is useful for debugging.
.ie n .IP "PushChildById( $parent, $button, $level, $delay )" 4
.el .IP "PushChildById( \f(CW$parent\fR, \f(CW$button\fR, \f(CW$level\fR, \f(CW$delay\fR )" 4
.IX Item "PushChildById( $parent, $button, $level, $delay )"
Allows pushing a button, which control id is eqaul to a given parameter.
\&\f(CW\*(C`PushChildButton\*(C'\fR tries to match parameter against control id or
caption.
PushChildById matches only against control id. Secondly, PushChildById
allows specifying search depth in the windows hierarchy tree.
The default is 2, which means that only direct children will be
pushed.
.IP "WaitWindowLike($parent,$wndtitle,$wndclass,$wndid,$depth,$wait)" 4
.IX Item "WaitWindowLike($parent,$wndtitle,$wndclass,$wndid,$depth,$wait)"
Function which allows one to wait for a window to appear
vs. using hard waits (e.g. sleep 2).
.Sp
parent   \- Where to start (parent window)
.Sp
wndtitle \- Regexp for the window title
.Sp
wndclass \- Regexp for the window class name
.Sp
wndid    \- Numeric Window or Control \s-1ID\s0
.Sp
depth    \- How deep should we search before we stop
.Sp
wait     \- How many seconds should we wait before giving up
.IP "WaitWindow($wndtitle,[$wait])" 4
.IX Item "WaitWindow($wndtitle,[$wait])"
Minimal version of WaitWindowLike. Only requires the window title
regexp. You can also specify the wait timeout in seconds.
.Sp
wndtitle \- Regexp for the window title
.Sp
wait     \- How many seconds should we wait before giving up
.ie n .IP "IsWindowStyle($window, $style)" 4
.el .IP "IsWindowStyle($window, \f(CW$style\fR)" 4
.IX Item "IsWindowStyle($window, $style)"
.Vb 2
\&    Determines if a window has the specified style.  See sample
\&    script for more details.
.Ve
.ie n .IP "IsWindowStyleEx($window, $exstyle)" 4
.el .IP "IsWindowStyleEx($window, \f(CW$exstyle\fR)" 4
.IX Item "IsWindowStyleEx($window, $exstyle)"
.Vb 2
\&    Determines if a window has the specified extended
\&    style.  See sample script for more details.
.Ve
.IP "GetMenu" 4
.IX Item "GetMenu"
Using the corresponding library function (see \s-1MSDN\s0) it returns a MenuID number
.ie n .IP "GetMenuItemIndex($curr, $menu);" 4
.el .IP "GetMenuItemIndex($curr, \f(CW$menu\fR);" 4
.IX Item "GetMenuItemIndex($curr, $menu);"
\&\f(CW$curr\fR is a MenuId and \f(CW$menu\fR is the (localized !) name of the menu including the hot
key:  \*(L"Rep&eate\*(R"  
Returns the index of the menu item (\-1 if not found)
.IP "GetMenuItemCount($menu)" 4
.IX Item "GetMenuItemCount($menu)"
Returns the number of elements in the given menu.
.IP "MenuSelect($menupath,$window,$menu)" 4
.IX Item "MenuSelect($menupath,$window,$menu)"
Allows selecting a menu programmatically.
.Sp
Simple Examples:
    # Exit foreground application through application menu.
    MenuSelect(\*(L"&File|E&xit\*(R");
.Sp
.Vb 2
\&    # Exit foreground application through system menu
\&    MenuSelect("&Close", 0, GetSystemMenu(GetForegroundWindow(), FALSE));
.Ve
.ie n .IP "GetMenuItemInfo($menuHndl, $cnt)" 4
.el .IP "GetMenuItemInfo($menuHndl, \f(CW$cnt\fR)" 4
.IX Item "GetMenuItemInfo($menuHndl, $cnt)"
Receives a menu handler (one we got from GetMenu or GetSubMenu) and
a number (which is the location of the item within the given menu).
.Sp
Returns a hash of which there are currently 2 keys:
type can be either \*(L"string\*(R" or \*(L"separator\*(R"  \- this is the type of the menu item
text is the visible text of the menu item (provided only for \*(L"string\*(R" type)
.Sp
\&\s-1WARNING:\s0 This is an experimental function. Its behavior might change.
.IP "MouseClick($window [,$parent] [,$x_offset] [,$y_offset] [,$button] [,$delay])" 4
.IX Item "MouseClick($window [,$parent] [,$x_offset] [,$y_offset] [,$button] [,$delay])"
Allows one to easily interact with an application through mouse emulation.
.Sp
window = Regexp for a Window caption / Child caption, or just a Child \s-1ID.\s0
.Sp
parent = Handle to parent window.  Default is foreground window.  Use
\&\fIGetDesktopWindow()\fR return value for this if clicking on an application
title bar.
.Sp
x_offset = Offset for X axis.  Default is 0.
.Sp
y_offset = Offset for Y axis.  Default is 0.
.Sp
button = {\s-1LEFT\s0}, {\s-1MIDDLE\s0}, {\s-1RIGHT\s0}.  Default is {\s-1LEFT\s0}
.Sp
delay = Default is 0.  0.50 = 500 ms.  Delay between button down and
button up.
.Sp
Simple Examples:
.Sp
.Vb 2
\&    # Click on CE button if its parent window is in foreground.
\&    MouseClick(\*(Aq^CE$\*(Aq);
\&
\&    # Right click on CE button if its parent window is in foreground
\&    MouseClick(\*(Aq^CE$\*(Aq, undef, undef, undef, \*(Aq{RIGHT}\*(Aq);
\&
\&    # Click on 8 button window under the specified parent window; where
\&    # [PARENTHWND] will be replaced by a parent handle variable.
\&    MouseClick(\*(Aq8\*(Aq, [PARENTHWND]);
\&
\&    # Click on Calculator parent window itself
\&    MouseClick(\*(AqCalculator\*(Aq, GetDesktopWindow());
.Ve
.ie n .IP "$buf_str = AllocateVirtualBuffer( $hwnd, $size )" 4
.el .IP "\f(CW$buf_str\fR = AllocateVirtualBuffer( \f(CW$hwnd\fR, \f(CW$size\fR )" 4
.IX Item "$buf_str = AllocateVirtualBuffer( $hwnd, $size )"
Allocates memory in the address space of the process, which is an owner of
a window identified by \f(CW$hwnd\fR. Returns a reference to a hash, which has 2 elements:
.RS 4
.IP "ptr \- address of the allocated memory" 8
.IX Item "ptr - address of the allocated memory"
.PD 0
.IP "process \- process handle (in the Win32 meaning, as returned by Win32 OpenProcess \s-1API\s0 function" 8
.IX Item "process - process handle (in the Win32 meaning, as returned by Win32 OpenProcess API function"
.RE
.RS 4
.RE
.ie n .IP "$value = ReadFromVirtualBuffer( $buf_str, $size )" 4
.el .IP "\f(CW$value\fR = ReadFromVirtualBuffer( \f(CW$buf_str\fR, \f(CW$size\fR )" 4
.IX Item "$value = ReadFromVirtualBuffer( $buf_str, $size )"
.PD
Read from a memory in the address space of the other process.
\&\f(CW$buf_str\fR is a reference to a hash returned by AllocateVirtualBuffer.
.Sp
Returns read value.
.ie n .IP "WriteToVirtualBuffer( $buf_str, $value )" 4
.el .IP "WriteToVirtualBuffer( \f(CW$buf_str\fR, \f(CW$value\fR )" 4
.IX Item "WriteToVirtualBuffer( $buf_str, $value )"
Write to a memory in the address space of the other process.
\&\f(CW$buf_str\fR is a reference to a hash returned by AllocateVirtualBuffer.
\&\f(CW$value\fR is a value to be copied.
.ie n .IP "FreeVirtualBuffer( $buf_str )" 4
.el .IP "FreeVirtualBuffer( \f(CW$buf_str\fR )" 4
.IX Item "FreeVirtualBuffer( $buf_str )"
Frees memory allocated by AllocateVirtualBuffer
.ie n .IP "$text = WMGetText($hwnd) *" 4
.el .IP "\f(CW$text\fR = WMGetText($hwnd) *" 4
.IX Item "$text = WMGetText($hwnd) *"
Sends a \s-1WM_GETTEXT\s0 to a window and returns its contents
.ie n .IP "$set = WMSetText(hwnd,text) *" 4
.el .IP "\f(CW$set\fR = WMSetText(hwnd,text) *" 4
.IX Item "$set = WMSetText(hwnd,text) *"
Sends a \s-1WM_SETTEXT\s0 to a window setting its contents
.IP "($x,$y) = \fIGetCursorPos()\fR *" 4
.IX Item "($x,$y) = GetCursorPos() *"
Retrieves the cursor's position,in screen coordinates as (x,y) array.
.IP "\fIGetCaretPos()\fR" 4
.IX Item "GetCaretPos()"
Retrieves the caret's position, in client coordinates as (x,y) array. (Like Windows function)
.IP "\s-1HWND\s0 SetFocus(hWnd)" 4
.IX Item "HWND SetFocus(hWnd)"
Sets the keyboard focus to the specified window
.IP "\s-1HWND\s0 \fIGetDesktopWindow()\fR *" 4
.IX Item "HWND GetDesktopWindow() *"
Returns a handle to the desktop window
.IP "\s-1HWND\s0 GetWindow(hwnd,uCmd) *" 4
.IX Item "HWND GetWindow(hwnd,uCmd) *"
.PD 0
.IP "\s-1SV\s0 * GetWindowText(hwnd) *" 4
.IX Item "SV * GetWindowText(hwnd) *"
.PD
Get the text name of the window as shown on the top of it.
Beware, this is text depends on localization.
.ie n .IP "$class = GetClassName(hwnd) *" 4
.el .IP "\f(CW$class\fR = GetClassName(hwnd) *" 4
.IX Item "$class = GetClassName(hwnd) *"
Using the same Windows library function returns the name
of the class wo which the specified window belongs.
.Sp
See \s-1MSDN\s0 for more details.
.Sp
You can also check out \s-1MSDN\s0 to see an overview of the Window Classes.
.IP "\s-1HWND\s0 GetParent(hwnd) *" 4
.IX Item "HWND GetParent(hwnd) *"
A library function (see \s-1MSDN\s0) to return the WindowID of the parent window.
See \s-1MSDN\s0 for the special cases.
.IP "long GetWindowLong(hwnd,index) *" 4
.IX Item "long GetWindowLong(hwnd,index) *"
.PD 0
.IP "\s-1BOOL\s0 SetForegroundWindow(hWnd) *" 4
.IX Item "BOOL SetForegroundWindow(hWnd) *"
.PD
See corresponding Windows functions.
.ie n .IP "@wnds = GetChildWindows(hWnd)" 4
.el .IP "\f(CW@wnds\fR = GetChildWindows(hWnd)" 4
.IX Item "@wnds = GetChildWindows(hWnd)"
Using EnumChildWindows library function (see \s-1MSDN\s0) it returns the WindowID 
of each child window. If the children have their own children the function
returns them too until the tree ends.
.IP "\s-1BOOL\s0 IsChild(hWndParent,hWnd) *" 4
.IX Item "BOOL IsChild(hWndParent,hWnd) *"
Using the corresponding library function (see \s-1MSDN\s0) it returns true
if the second window is an immediate child or a descendant window of
the first window.
.ie n .IP "$depth = GetChildDepth(hAncestor,hChild)" 4
.el .IP "\f(CW$depth\fR = GetChildDepth(hAncestor,hChild)" 4
.IX Item "$depth = GetChildDepth(hAncestor,hChild)"
Using the GetParent library function in a loop, returns the distance
between an ancestor window and a child (descendant) window.
.Sp
Features/bugs:
If the given \*(L"ancsetor\*(R" is not really an ancestor, the return value is the distance of child from the root window (0)
If you supply the same id for both the ancestor and the child you get 1.
If the ancestor you are checking is not 0 then the distance given is 1 larger than it should be.
.Sp
see eg\eget_child_depth.pl
.ie n .IP "$res = SendMessage(hWnd,Msg,wParam,lParam) *" 4
.el .IP "\f(CW$res\fR = SendMessage(hWnd,Msg,wParam,lParam) *" 4
.IX Item "$res = SendMessage(hWnd,Msg,wParam,lParam) *"
This is a library function (see \s-1MSDN\s0) used by a number of the functions provided by
Win32::GuiTest. It sends the specified message to a window or windows.
HWnd is the WindowID or \s-1HWND_BROADCAST\s0 to send message to all top level windows.
     Message is not sent to child windows. (If I understand this correctly this means
     it is sent to all the immediate children of the root window (0).
Msg  the message
wParam additional parameter
lParam additioanl parameter
.Sp
It is most likely you won't use this directly but through one of the functions
implemented already in Win32::GuiTest.
.Sp
See the guitest.xs for some examples.
.ie n .IP "$res = PostMessage(hwnd,msg,wParam,lParam) *" 4
.el .IP "\f(CW$res\fR = PostMessage(hwnd,msg,wParam,lParam) *" 4
.IX Item "$res = PostMessage(hwnd,msg,wParam,lParam) *"
See corresponding Windows library function in \s-1MSDN.\s0
.IP "CheckButton(hwnd)" 4
.IX Item "CheckButton(hwnd)"
.PD 0
.IP "UnCheckButton(hwnd)" 4
.IX Item "UnCheckButton(hwnd)"
.IP "GrayOutButton(hwnd)" 4
.IX Item "GrayOutButton(hwnd)"
.IP "\s-1BOOL\s0 IsCheckedButton(hwnd)" 4
.IX Item "BOOL IsCheckedButton(hwnd)"
.IP "\s-1BOOL\s0 IsGrayedButton(hwnd)" 4
.IX Item "BOOL IsGrayedButton(hwnd)"
.PD
The names say it.  Works on radio buttons and
checkboxes.  For regular buttons, use IsWindowEnabled.
.IP "\s-1BOOL\s0 IsWindow(hwnd) *" 4
.IX Item "BOOL IsWindow(hwnd) *"
.PD 0
.IP "($x,$y) = ScreenToClient(hwnd,x,y) *" 4
.IX Item "($x,$y) = ScreenToClient(hwnd,x,y) *"
.IP "($x,$y) = ClientToScreen(hwnd,x,y) *" 4
.IX Item "($x,$y) = ClientToScreen(hwnd,x,y) *"
.IP "($x,$y) = GetCaretPos(hwnd) *A" 4
.IX Item "($x,$y) = GetCaretPos(hwnd) *A"
.IP "\s-1HWND\s0 SetFocus(hWnd) *A" 4
.IX Item "HWND SetFocus(hWnd) *A"
.IP "\s-1HWND\s0 GetFocus(hwnd) *A" 4
.IX Item "HWND GetFocus(hwnd) *A"
.IP "\s-1HWND\s0 GetActiveWindow(hwnd) *A" 4
.IX Item "HWND GetActiveWindow(hwnd) *A"
.IP "\s-1HWND\s0 \fIGetForegroundWindow()\fR *" 4
.IX Item "HWND GetForegroundWindow() *"
.IP "\s-1HWND\s0 SetActiveWindow(hwnd) *A" 4
.IX Item "HWND SetActiveWindow(hwnd) *A"
.IP "\s-1BOOL\s0 EnableWindow(hwnd,fEnable) *" 4
.IX Item "BOOL EnableWindow(hwnd,fEnable) *"
.IP "\s-1BOOL\s0 IsWindowEnabled(hwnd)*" 4
.IX Item "BOOL IsWindowEnabled(hwnd)*"
.IP "\s-1BOOL\s0 IsWindowVisible(hwnd)*" 4
.IX Item "BOOL IsWindowVisible(hwnd)*"
.IP "\s-1BOOL\s0 ShowWindow(hwnd,nCmdShow) *A" 4
.IX Item "BOOL ShowWindow(hwnd,nCmdShow) *A"
.PD
See corresponding Windows functions.
.IP "($x,$y) = ScreenToNorm(x,y)" 4
.IX Item "($x,$y) = ScreenToNorm(x,y)"
Returns normalised coordinates of given point (0\-FFFF as a fraction of screen 
resolution)
.IP "($x,$y) = NormToScreen(x,y)" 4
.IX Item "($x,$y) = NormToScreen(x,y)"
The opposite transformation
.IP "($x,$y) = \fIGetScreenRes()\fR" 4
.IX Item "($x,$y) = GetScreenRes()"
Returns screen resolution
.IP "\s-1HWND\s0 WindowFromPoint(x, y)" 4
.IX Item "HWND WindowFromPoint(x, y)"
.PD 0
.IP "($l,$t,$r,$b) = GetWindowRect(hWnd) *" 4
.IX Item "($l,$t,$r,$b) = GetWindowRect(hWnd) *"
.IP "($l,$t,$r,$b) = GetClientRect(hWnd) *" 4
.IX Item "($l,$t,$r,$b) = GetClientRect(hWnd) *"
.PD
See corresponding Windows functions.
.ie n .IP "SelComboItem($window, $index)" 4
.el .IP "SelComboItem($window, \f(CW$index\fR)" 4
.IX Item "SelComboItem($window, $index)"
Selects an item in the combo box based off an index (zero-based).
.ie n .IP "SelComboItemText($window, $txt)" 4
.el .IP "SelComboItemText($window, \f(CW$txt\fR)" 4
.IX Item "SelComboItemText($window, $txt)"
Selects an item in the combo box based off text (case insensitive).
.ie n .IP "$txt = GetComboText(hwnd,index)" 4
.el .IP "\f(CW$txt\fR = GetComboText(hwnd,index)" 4
.IX Item "$txt = GetComboText(hwnd,index)"
.PD 0
.ie n .IP "$txt = GetListText(hwnd,index)" 4
.el .IP "\f(CW$txt\fR = GetListText(hwnd,index)" 4
.IX Item "$txt = GetListText(hwnd,index)"
.ie n .IP "@lst = GetComboContents(hWnd)" 4
.el .IP "\f(CW@lst\fR = GetComboContents(hWnd)" 4
.IX Item "@lst = GetComboContents(hWnd)"
.ie n .IP "@lst = GetListContents(hWnd)" 4
.el .IP "\f(CW@lst\fR = GetListContents(hWnd)" 4
.IX Item "@lst = GetListContents(hWnd)"
.PD
Fetch the contents of the list and combo boxes.
.IP "GetAsyncKeyState($key)" 4
.IX Item "GetAsyncKeyState($key)"
.PD 0
.IP "IsKeyPressed($key)" 4
.IX Item "IsKeyPressed($key)"
.PD
Wrapper around the GetAsyncKeyState \s-1API\s0 function. Returns \s-1TRUE\s0 if the user presses the 
specified key.
.Sp
.Vb 4
\&    IsKeyPressed("ESC");
\&    IsKeyPressed("A");
\&    IsKeyPressed("DOWN"); 
\&    IsKeyPressed( VK_DOWN);
.Ve
.IP "SendRawKey($virtualkey,$flags)" 4
.IX Item "SendRawKey($virtualkey,$flags)"
Wrapper around keybd_event. Allows sending low-level keys. The first argument is any of the VK_* constants. The second argument can be 0, \s-1KEYEVENTF_EXTENDEDKEY, KEYEVENTF_KEYUP\s0 or a combination of them.
.Sp
.Vb 2
\&    KEYEVENTF_EXTENDEDKEY \- Means it is an extended key (i.e. to distinguish between arrow keys on the numeric keypad and elsewhere). 
\&    KEYEVENTF_KEYUP       \- Means keyup. Unspecified means keydown.
\&
\&   #Example
\&   use Win32::GuiTest qw/:FUNC :VK/;
\&
\&   while (1) {
\&       SendRawKey(VK_DOWN, KEYEVENTF_EXTENDEDKEY); 
\&       SendKeys "{PAUSE 200}";
\&   }
.Ve
.IP "VkKeyScan(int)" 4
.IX Item "VkKeyScan(int)"
.PD 0
.ie n .IP """GetListViewContents($handle)""" 4
.el .IP "\f(CWGetListViewContents($handle)\fR" 4
.IX Item "GetListViewContents($handle)"
.PD
.Vb 3
\&    Return the items of the list view with C<$handle> as a list, each
\&        element of which is a reference to an array containing the values
\&        in each column.
.Ve
.ie n .IP "SelListViewItem($window, $idx, [$multi_select])" 4
.el .IP "SelListViewItem($window, \f(CW$idx\fR, [$multi_select])" 4
.IX Item "SelListViewItem($window, $idx, [$multi_select])"
.Vb 1
\&    Selects an item in the list view based off an index (zero\-based).
\&
\&        # Select first item, clears out any previous selections.
\&        SelListViewItem($win, 0);
\&        # Select an *additional* item.
\&        SelListViewItem($win, 1, 1);
.Ve
.ie n .IP "SelListViewItemText($window, $txt, [$multi_select])" 4
.el .IP "SelListViewItemText($window, \f(CW$txt\fR, [$multi_select])" 4
.IX Item "SelListViewItemText($window, $txt, [$multi_select])"
.Vb 1
\&    Selects an item in the list view based off text (case insensitive).
\&
\&        # Select first item, clears out any previous selections.
\&        SelListViewItemText($win, \*(AqTemp\*(Aq);
\&        # Select an *additional* item.
\&        SelListViewItemText($win, \*(Aqcabs\*(Aq, 1);
.Ve
.ie n .IP "IsListViewItemSel($window, $txt)" 4
.el .IP "IsListViewItemSel($window, \f(CW$txt\fR)" 4
.IX Item "IsListViewItemSel($window, $txt)"
.Vb 1
\&   Determines if the specified list view item is selected.
.Ve
.IP "GetTabItems($window)" 4
.IX Item "GetTabItems($window)"
.Vb 1
\&    Returns a list of a tab control\*(Aqs labels.
.Ve
.ie n .IP "SelTabItem($window, $idx)" 4
.el .IP "SelTabItem($window, \f(CW$idx\fR)" 4
.IX Item "SelTabItem($window, $idx)"
.Vb 1
\&    Selects a tab based off an index (zero\-based).
.Ve
.ie n .IP "SelTabItemText($window, $txt)" 4
.el .IP "SelTabItemText($window, \f(CW$txt\fR)" 4
.IX Item "SelTabItemText($window, $txt)"
.Vb 1
\&    Selects a tab based off text label (case insensitive).
.Ve
.ie n .IP "IsTabItemSel($window, $txt)" 4
.el .IP "IsTabItemSel($window, \f(CW$txt\fR)" 4
.IX Item "IsTabItemSel($window, $txt)"
.Vb 1
\&   Determines if the specified tab item is selected.
.Ve
.ie n .IP "SelTreeViewItemPath($window, $path)" 4
.el .IP "SelTreeViewItemPath($window, \f(CW$path\fR)" 4
.IX Item "SelTreeViewItemPath($window, $path)"
.Vb 1
\&    Selects a tree view item based off a "path" (case insensitive).
\&
\&    # Select Machine item and Processors sub\-item.
\&    SelTreeViewItemPath($window, "Machine|Processors");
\&
\&    SelTreeViewItemPath($window, "Item");
.Ve
.IP "GetTreeViewSelPath($window)" 4
.IX Item "GetTreeViewSelPath($window)"
.Vb 2
\&   Returns a string containing the path (i.e., "parent|child") of
\&   the currently selected tree view item.
\&
\&   $oldpath = GetTreeViewSelPath($window);
\&   SelTreeViewItemPath($window, "Parent|Child");
\&   SelTreeViewItemPath($window, $oldpath);
.Ve
.ie n .IP "$hpopup = GetPopupHandle($hwnd, $x, $y, [$wait])" 4
.el .IP "\f(CW$hpopup\fR = GetPopupHandle($hwnd, \f(CW$x\fR, \f(CW$y\fR, [$wait])" 4
.IX Item "$hpopup = GetPopupHandle($hwnd, $x, $y, [$wait])"
.Vb 5
\&   This function gets the handle of a popup window generated by
\&   right\-clicking at the $x and $y screen coordinates (absolute). An
\&   optional delay can be entered which will wait the given number of
\&   milliseconds after the right\-click for the window to appear (default
\&   is 50). Zero is returned when no popup menu is found.
.Ve
.SS "DibSect"
.IX Subsection "DibSect"
A class to manage a Windows \s-1DIB\s0 section. Currently limited in functionality to 
24\-bit images. Pulled from old code into GuiTest when I (jurasz@imb.uni\-karlsruhe.de) 
needed to create several grayscale screen dumps.
.PP
Possible future extenstions: other color resolutions, loading, comparison of bitmaps,
getting from clipboard.
.PP
Synopsis:
.PP
.Vb 5
\&  $ds = new Win32::GuiTest::DibSect;
\&  $ds\->CopyWindow($w);
\&  $ds\->ToGrayScale();
\&  $ds\->SaveAs("bla.bmp");
\&  $ds\->ToClipboard();
.Ve
.IP "bool DibSect::CopyClient(hwnd,[rect])" 8
.IX Item "bool DibSect::CopyClient(hwnd,[rect])"
Copy a client area of given window (or possibly its subset) into a given DibSect.
The rectangle may be optionally passed as a reference to 4\-element array.
To get the right result make sure the window you want to copy is not obscured by 
others.
.IP "bool DibSect::CopyWindow(hwnd)" 8
.IX Item "bool DibSect::CopyWindow(hwnd)"
Copy the window rectangle. Equivalent to
.Sp
.Vb 1
\&  $ds\->CopyClient(GetDesktopWindow(), \e@{[GetWindowRect($w)]});
.Ve
.IP "bool DibSect::SaveAs(szFile)" 8
.IX Item "bool DibSect::SaveAs(szFile)"
Save the current contents of the \s-1DIB\s0 section in a given file. With 24\-bit 
resolution it can grow quite big, so I immediately convert them to \s-1PNG \s0(direct 
writing of \s-1PNG\s0 seemed to complicated to implement).
.IP "bool \fIDibSect::Invert()\fR" 8
.IX Item "bool DibSect::Invert()"
Invert the colors in a current \s-1DIB\s0 section.
.IP "bool \fIDibSect::ToGrayScale()\fR" 8
.IX Item "bool DibSect::ToGrayScale()"
Convert the DibSection to the gray scale. Note that it is still encoded as 24\-bit
\&\s-1BMP\s0 for simplicity.
.IP "bool \fIDibSect::ToClipboard()\fR" 8
.IX Item "bool DibSect::ToClipboard()"
Copies the DibSect to clipboard (as an old-fashioned metafile), so that it can 
be further processed with your favourite image processing software, for example 
automatically using SendKeys.
.IP "bool \fIDibSect::Destroy()\fR" 8
.IX Item "bool DibSect::Destroy()"
Destroys the contents of the \s-1DIB\s0 section.
.SH "UNICODE SUPPORT"
.IX Header "UNICODE SUPPORT"
Currently (2007) there's no consensus about unicode input in Perl, so
the module declares function \f(CW\*(C`UnicodeSemantics\*(C'\fR that sets whether 
information queried from windows should use A or W syscalls. The
function that support this differentiation, and produce different
results depending on value set to \f(CW\*(C`UnicodeSemantics\*(C'\fR is:
.PP
\&\f(CW\*(C`GetWindowText\*(C'\fR, and all its callers, \- FindWindowLike, WaitWindow,
WaitWindowLike
.PP
\&\f(CW\*(C`SendKeys\*(C'\fR translated unicode characters into set of \s-1ALT+NUMPAD\s0 keystrokes.
Note that not all applications can understand unicode input.
.IP "UnicodeSemantics [\s-1BOOL\s0]" 4
.IX Item "UnicodeSemantics [BOOL]"
If a boolean parameter is set, changes the semantics flag for functions
that return results of either A or W syscalls. If the parameter is
not set, returns the current value of the flag.
.SH "DEVELOPMENT"
.IX Header "DEVELOPMENT"
If you would like to participate in the development of this module there are 
several thing that need to be done. For some of them you only need Perl
and the latest source of the module from \s-1CVS\s0 for others you'll also need to 
have a \*(C+ compiler.
.PP
To get the latest source code you need a \s-1CVS\s0 client and then do the following:
.PP
.Vb 2
\& cvs \-d:pserver:anonymous@cvs.sourceforge.net:/cvsroot/winguitest login
\& cvs \-z3 \-d:pserver:anonymous@cvs.sourceforge.net:/cvsroot/winguitest co Win32\-GuiTest
.Ve
.PP
See more detailed explanations here http://sourceforge.net/projects/winguitest/
.SS "cygwin"
.IX Subsection "cygwin"
g++ needs to be installed
.PP
.Vb 4
\&  perl Makefile.PL
\&  make
\&  make test
\&  make install
.Ve
.SS "\s-1MSVC\s0 environment"
.IX Subsection "MSVC environment"
To setup a development environment for compiling the \*(C+ code you can either buy
Visual Studio with Visual \*(C+ or you can download a few things free of charge from 
Microsoft. There might be other ways too we have not explored.
.PP
The instructions to get the free environment are here:
.PP
From http://www.microsoft.com/ download and install:
.PP
.Vb 2
\& 1) Microsoft .NET Framework Version 1.1 Redistributable Package
\& 2) .NET Framework SDK Version 1.1
.Ve
.PP
This is not enough as there are a number of header files and libraries that are 
not included in these distributions. You can get them from Microsoft in two additional
downloads. For these you will have to be using Internet Explorer.
Visit
.PP
.Vb 1
\&  http://www.microsoft.com/msdownload/platformsdk/sdkupdate/
.Ve
.PP
and install
.PP
.Vb 2
\& 1) Core SDK
\& 2) Microsoft Data Access Components 2.7
.Ve
.PP
Before you can compile you'll have to open a command prompt and execute the
\&\f(CW\*(C`sdkvars.bat\*(C'\fR script from the.NET \s-1SDK\s0 that will set a number of environment
variables. In addition you'll have to run the \f(CW\*(C`setenv.bat\*(C'\fR you got with the 
Core \s-1SDK \s0(and located in C:\eProgram Files\eMicrosoft \s-1SDK\s0) with the appropriate
parameters. For me this was /XP32 /RETAIL
.PP
In order to finish the packaging you'll also need the tar, gzip and zip utilities from
.PP
.Vb 1
\& http://gnuwin32.sourceforge.net/packages.html
.Ve
.PP
I have not tried it yet.
.PP
After this you will probably be able to do the normal cycle:
.PP
.Vb 3
\& perl makefile.pl
\& nmake
\& nmake test
\&
\& or run
\&
\& perl makedist.pl
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Module's documentation is available at <http://www.piotrkaluski.com/files/winguitest/docs/index.html>.
.SH "TODO"
.IX Header "TODO"
Here are a few items where help would be welcome.
.SS "Perl only"
.IX Subsection "Perl only"
.Vb 3
\& Improve Tests
\& Improve documentation
\& Add more examples and explain them
.Ve
.SS "\*(C+ compiler needed"
.IX Subsection " compiler needed"
.Vb 2
\& Add more calls to the C++ backend
\& Fix current calls
\&
\& 32bit custom controls (some already implemented)
\& Possibly Java interfaces
\& Retreive the list of the menu of a given window.
.Ve
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
The SendKeys function is based on the Delphi sourcecode
published by Al Williams  <http://www.al\-williams.com/awc/> 
in Dr.Dobbs  <http://www.ddj.com/ddj/1997/careers1/wil2.htm>.
.PP
Copyright (c) 1998\-2002 Ernesto Guisado, (c) 2004 Dennis K. Paulsen. All rights 
reserved. This program is free software; You may distribute it and/or modify it
under the same terms as Perl itself.
.SH "AUTHORS"
.IX Header "AUTHORS"
Ernesto Guisado (erngui@acm.org), http://triumvir.org
.PP
Jarek Jurasz (jurasz@imb.uni\-karlsruhe.de), http://www.uni\-karlsruhe.de/~gm07 wrote 
DibSect and some other pieces (see \f(CW\*(C`Changes\*(C'\fR for details).
.PP
Dennis K. Paulsen (ctrondlp@cpan.org) wrote various pieces (See \f(CW\*(C`Changes\*(C'\fR for
details).
.PP
Dmitry Karasik (dmitry@karasik.eu.org) added support for unicode and cygwin/mingw.
.SH "CREDITS"
.IX Header "CREDITS"
Thanks very much to:
.IP "Johannes Maehner" 4
.IX Item "Johannes Maehner"
.PD 0
.IP "Ben Shern" 4
.IX Item "Ben Shern"
.IP "Phill Wolf" 4
.IX Item "Phill Wolf"
.IP "Mauro" 4
.IX Item "Mauro"
.IP "Sohrab Niramwalla" 4
.IX Item "Sohrab Niramwalla"
.IP "Frank van Dijk" 4
.IX Item "Frank van Dijk"
.IP "Jarek Jurasz" 4
.IX Item "Jarek Jurasz"
.IP "Wilson P. Snyder \s-1II\s0" 4
.IX Item "Wilson P. Snyder II"
.IP "Rudi Farkas" 4
.IX Item "Rudi Farkas"
.IP "Paul Covington" 4
.IX Item "Paul Covington"
.IP "Piotr Kaluski" 4
.IX Item "Piotr Kaluski"
.IP "...and more..." 4
.IX Item "...and more..."
.PD
for code, suggestions and bug fixes.
